
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://rdrvashvfvjdtuuuqjio.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJkcnZhc2h2ZnZqZHR1dXVxamlvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDIzNDE2NzIsImV4cCI6MjA1NzkxNzY3Mn0.sP3DXiJwRaOnPWMhc8YNLkrIB16SZIXbp-jvG40hdY0";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    storageKey: 'vitalis-auth-token',
    detectSessionInUrl: false
  },
  global: {
    // Extended timeout for longer operations
    fetch: (url, options = {}) => {
      // Ensure options and headers exist to fix TypeScript errors
      const fetchOptions = { ...options };
      fetchOptions.headers = fetchOptions.headers || {};
      
      // Set longer timeout for large data operations
      const timeoutController = new AbortController();
      const timeoutId = setTimeout(() => timeoutController.abort(), 120000); // 2 minutes timeout
      
      // Add signal to options
      fetchOptions.signal = timeoutController.signal;
      
      // Log request details in development
      if (import.meta.env.DEV) {
        console.log(`Supabase request to: ${url}`, { 
          headers: fetchOptions.headers,
          method: fetchOptions.method || 'GET'
        });
      }
      
      return fetch(url, fetchOptions).finally(() => clearTimeout(timeoutId));
    }
  }
});

// Simple helper to check if there's a valid session in storage
export const hasStoredSession = () => {
  try {
    const storageKey = 'vitalis-auth-token';
    const stored = localStorage.getItem(storageKey);
    if (!stored) return false;
    
    const parsedData = JSON.parse(stored);
    if (!parsedData?.currentSession) return false;
    
    const expiryTime = parsedData.currentSession.expires_at * 1000;
    // Add a 5-minute buffer to be safe
    const bufferTime = 5 * 60 * 1000; 
    return new Date(expiryTime - bufferTime) > new Date();
  } catch (error) {
    console.error('Error checking stored session:', error);
    return false;
  }
};

// Helper to get current token with validation
export const getCurrentToken = async () => {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (session?.access_token) {
      // Verify token expiration
      const now = Math.floor(Date.now() / 1000);
      // Add a 5-minute buffer to be safe
      const bufferTime = 5 * 60;
      
      if (session.expires_at && (session.expires_at - bufferTime) > now) {
        // Log the token for debugging (masked for security)
        const tokenLength = session.access_token.length;
        const maskedToken = tokenLength > 10 ? 
          `${session.access_token.substring(0, 5)}...${session.access_token.substring(tokenLength - 5)}` : 
          'token too short';
        console.log(`Current token (masked): ${maskedToken}, length: ${tokenLength}, expires: ${new Date(session.expires_at * 1000).toISOString()}`);
        
        return session.access_token;
      }
      
      // Token expired or close to expiring, try to refresh
      console.log('Token expired or close to expiring, refreshing...');
      const { data } = await supabase.auth.refreshSession();
      
      if (data.session?.access_token) {
        const newTokenLength = data.session.access_token.length;
        const newMaskedToken = newTokenLength > 10 ? 
          `${data.session.access_token.substring(0, 5)}...${data.session.access_token.substring(newTokenLength - 5)}` : 
          'token too short';
        console.log(`Refreshed token (masked): ${newMaskedToken}, length: ${newTokenLength}, expires: ${new Date(data.session.expires_at * 1000).toISOString()}`);
      } else {
        console.warn('Failed to get refreshed token');
      }
      
      return data.session?.access_token;
    }
    
    console.warn('No session token available');
    return null;
  } catch (error) {
    console.error('Error getting current token:', error);
    return null;
  }
};

// Function to test token validity with the test-connection function
export const testTokenValidity = async () => {
  try {
    const token = await getCurrentToken();
    if (!token) {
      return { valid: false, message: 'No token available' };
    }
    
    const response = await fetch(`${SUPABASE_URL}/functions/v1/test-connection`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });
    
    const result = await response.json();
    return { 
      valid: result.success,
      message: result.message,
      details: result
    };
  } catch (error) {
    return { 
      valid: false, 
      message: error instanceof Error ? error.message : 'Error testing token validity',
      error
    };
  }
};

// Function to test edge functions auth with the validation function
export const diagnoseAuthIssues = async () => {
  try {
    const token = await getCurrentToken();
    if (!token) {
      return { valid: false, message: 'No token available' };
    }
    
    // Log details about the token
    console.log(`Making auth validation request with token length: ${token.length}`);
    console.log(`Token first 10 chars: ${token.substring(0, 10)}...`);
    
    // Make the request with the Authorization header
    const response = await fetch(`${SUPABASE_URL}/functions/v1/auth/validate`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
        // Add additional header for debugging
        'X-Request-Time': new Date().toISOString()
      }
    });
    
    // Log the response status
    console.log(`Auth validation response status: ${response.status}`);
    
    // Parse the response
    const result = await response.json();
    console.log(`Auth validation result:`, result);
    
    return result;
  } catch (error) {
    console.error('Error in auth diagnosis:', error);
    return { 
      success: false, 
      message: error instanceof Error ? error.message : 'Error diagnosing authentication',
      error: String(error)
    };
  }
};
